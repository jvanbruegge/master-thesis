\chapter{Introduction}\label{chapter:introduction}

Reasoning about programming languages always requires dealing with variable binders. While in pen and paper proofs usually Barendregt's variable convention\cite{variable_convention} is used to assume that bound variables can be freely renamed to avoid all free variables, when trying to formalize such proofs in a proof assistant like Isabelle/HOL\cite{isabelle}, this assumption has to be proven true.
Over the years several tools have been developed that provide semi-automated infrastructure for this reasoning. The POPLmark challenge\cite{poplmark} defines several reasoning tasks with different complexity in binding patterns. The challenge allows to compare different reasoning tools easier with regard to expressiveness (which tasks are provable at all) and user supplied proofs needed (how much proof automation is possible).

\begin{itemize}
\item{Formal proofs about programming languages need to be able to deal with bound/free variables}
\item{Also needs capture avoiding substitution}
\item{Barendregt's variable convention makes proofs a lot easier, but in a formal setting, this convention has to be proven correct}
\item{Generalization of normal datatypes can deal with those issues and provide special induction principles with the variable convention builtin}
\item{Example of a simple lambda calculus}
\item{Show multi (recursive) let, with distinct variables (POPL Example 4)}
\end{itemize}
