\chapter{Future Work}

To make \ac{MRBNF}-based binder datatypes as easy and convenient to use, a lot more implementation work has to be done. First, as hinted in section~\ref{sec:user_spec}, the parser that converts the high level datatype definition into a sum of products is missing entirely. While Isabelle has parser combinators to parse for example types, the need to be able to select a variable inside a type (compare listing~\ref{lst:syntax_binder_datatype}) requires us to modify this combinator. Additionally to support distinct simultaneous variable binders, tactics to create a quotient type and to prove that this type is a \ac{MRBNF} need to be written.

While the \ac{MRBNF} fixpoint already implements the strengthened induction principles, it is not possible to define functions on binding datatypes. For this, implementing the \ac{MRBNF} recursor and exposing it to the user through a convenient \texttt{binder\_function} command (similar to \texttt{function} for normal datatypes) is necessary. Ideally the user should not be required to do any proofs about preserving freshness of bound variables.

The last important step is to change the cardinality requirements of sets of \acp{BNF} to be strictly less than the bound. As seen in section~\ref{sec:conversion}, sets of \acp{BNF} only need to have less or equal members compared to the bound. Thus, to convert \acp{BNF} to \acp{MRBNF}, the successor cardinal is used as bound. The problem with this approach is that it requires variable types of higher cardinalities than $\aleph_0$ even for finite datatypes (without nested codatatypes), ruling out common variable types like strings or natural numbers.
