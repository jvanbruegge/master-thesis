\chapter{MRBNF Construction}

Throughout this chapter we will follow the general procedure to create a \ac{MRBNF} from a user-defined specification. As an example, we will use the types and terms of System F as defined in figure~\ref{fig:systemf_syntax}. As deep recursive binders are of special interest, we extend the syntax to include \textit{let rec}. Another interesting point are the different kinds of binders in System F. In types, we have type variables which are bound with forall. In terms, we have term variables which are bound by normal lambda functions, but also type variables which are bound by big lambdas. For our binding aware data types we have to be able to nest the data type for types in the data type for term while sharing the binding scopes for type variables between the two.

\begin{figure}[H]
\[
\begin{array}{rcll}
\tau, \sigma & \bnfeq &  & \\ %\hspace{-24pt}\text{Types} \\
& \bnfor & a & \text{Variables} \\
& \bnfor & \tau_1 \: \tau_2 & \text{Application} \\
& \bnfor & \tau_1 \to \tau_2 & \text{Function Types} \\
& \bnfor & \forall a. \: \tau & \text{Polymorphism} \\
& & & \\
t, u & \bnfeq & & \\
& \bnfor & x & \text{Variables} \\
& \bnfor & t_1 \: t_2 & \text{Application} \\
& \bnfor & \lambda x\dv\tau. \: t & \text{Abstraction} \\
& \bnfor & t \: \sigma & \text{Type Application} \\
& \bnfor & \Lambda a . \: t & \text{Type Abstraction} \\
& \bnfor & \texttt{let} \: \overline{x = t} \: \texttt{in} \: u & \text{Recursive Let} \\
\end{array}
\]
\caption{Syntax of Types and Terms in System F}
\label{fig:systemf_syntax}
\end{figure}

\section{Parsing of user specification}

To provide the user with a high level interface, Isabelle allows to define new custom syntax. In fact, the current (non binding aware) data types that are based on \acp{BNF} are an example of such custom syntax (see listing~\ref{lst:datatype_isabelle}).

\begin{minipage}{\textwidth}
\begin{lstlisting}[
  language=Isabelle,
  caption=Defintion of a simple tree data type in Isabelle/HOL,
  label={lst:datatype_isabelle},
  otherkeywords={'a},
  keywordstyle=\color{tyvar}
]
datatype 'a tree =
    Leaf
  | Node "'a tree" 'a "'a tree"
\end{lstlisting}
\end{minipage}

This custom syntax is then transformed internally into a type definition with a single constructor that uses the standard binary sum and product types to represent the user-given data type. Additionally, constructors with no data are replaced by \textit{unit} and the recursive components of the type are replaced with variables. The example above would be translated to the type in listing~\ref{lst:pre_datatype}.

\begin{minipage}{\textwidth}
\begin{lstlisting}[
  language=Isabelle,
  caption=Defintion of the pre-datatype of a tree,
  label={lst:pre_datatype},
  otherkeywords={'a, 'b},
  keywordstyle=\color{tyvar}
]
unit
+ ('b * 'a * 'b)
\end{lstlisting}
\end{minipage}

Our binding aware data types should mirror the normal data type definitions, with additional annotation to denote binding relations. The fundamental approach of using \acp{MRBNF} allows us to delay the definition of such a syntax until after the rest of the contruction is implemented. This allows to mold the syntax to the final set of supported features instead of having to try to anticipate them in advance. Taking inspiration from Nominal2~\cite{nominal2}, for the terms of our System F example it might look similar to this:

\begin{lstlisting}[
  language=Isabelle,
  caption=Possible syntax for binding aware data types,
  label={lst:syntax_binder_datatype},
  literate=
    {@var@}{\textcolor{tyvar}{'var}}{1}
    {@tyvar@}{\textcolor{tyvar}{'tyvar}}{1}
]
binder_datatype (@var@, @tyvar@) term =
    Var @var@
  | App term term
  | Lam x::@var@ "@tyvar@ ty" t::term binds x in t
  | TyApp term "@tyvar@ ty"
  | TyLam a::@tyvar@ t::term binds a in t
  | Let "((xs::@var@) * (ts::term)) list" t::term binds xs in ts t, distinct xs
\end{lstlisting}

This syntax would be translated to the type in listing~\ref{lst:binding_type}. For every variable type, a second type variable is introduced to stand in for the bound variables (\texttt{\textcolor{tyvar}{'bvar}} for \texttt{\textcolor{tyvar}{'var}} and \texttt{\textcolor{tyvar}{'btyvar}} for \texttt{\textcolor{tyvar}{'tyvar}}). The recursive components are replaced with one of two variables depending if a variable is bound in the recursive part (\texttt{\textcolor{tyvar}{'body}}) or not (\texttt{\textcolor{tyvar}{'rec}}). These extra variables are required for the \ac{MRBNF} fixpoint (see chapter~\ref{sec:fixpoint}). In this thesis, we do not implement this translation and expect the user to provide the type directly.

\begin{lstlisting}[
  language=Isabelle,
  caption=Translation of the term binder data type of System F,
  label={lst:binding_type},
  otherkeywords={'var, 'tyvar, 'bvar, 'btyvar, 'body, 'rec},
  keywordstyle=\color{tyvar}
]
'var
+ ('rec * 'rec)
+ ('bvar * 'tyvar ty * 'body)
+ ('rec * 'tyvar ty)
+ ('btyvar * 'body)
+ (('bvar * 'body) list * 'body)
\end{lstlisting}

\section{Proof of the \ac{MRBNF} axioms by composition}

The construction of the fixpoint requires that the provided type is a \ac{MRBNF}. To prove the axioms, the user-provided type is divided into individual pieces and composed back together according to this algorithm:

\begin{algorithm}
\caption{Recursive construction of a composed \ac{MRBNF} from a type}\label{alg:mrbnf_of_typ}
\begin{algorithmic}[1]
\Function{MRBNF\_of\_typ}{$t, label$}
  \If{$t = \text{Var}('x)$}
    \State $\textit{var\_type}\gets label('x)$ \Comment{\textcolor{darkgreen}{is $'x$ Live, Free, Bound or Dead?}}
    \State \Return $\textit{demote}([\textit{var\_type}], \text{ID\_mrbnf}('x))$
  \ElsIf{$t = (t_1,...,t_n) G \: \textbf{and} \: G \: \text{is a MRBNF}$}
    \State $F_1,...,F_n\gets \Call{MRBNF\_of\_typ}{t_1, label},...,\Call{MRBNF\_of\_typ}{t_n, label}$
    \State \Return $\textit{compose\_mrbnf}(G, [F_1,...,F_n])$
  \ElsIf{$t = (t_1,...,t_n) G \: \textbf{and} \: G \: \text{is a BNF}$}
    \State $\textit{mrbnf\_of\_bnf}(G)$ \Comment{\textcolor{darkgreen}{Convert G to a MRBNF and register it for future use}}
    \State \Return \Call{MRBNF\_of\_typ}{$(t_1,...,t_n) G, label$}
  \Else
    \State \Return $\text{DEADID\_mrbnf}(t)$
  \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

Here, \textit{demote} refers to the function explained in section~\ref{sec:demote}, \textit{compose\_mrbnf} to the composition pipeline explained in section~\ref{sec:composition} and \textit{mrbnf\_of\_bnf} to the conversion function in section~\ref{sec:conversion}. In our example type from earlier (listing~\ref{lst:binding_type}) this composition would convert the product type \texttt{(*)}, the sum type \texttt{(+)} and the \texttt{list} type to \acp{MRBNF} and wrap every variable with the \text{ID\_mrbnf} demoted using the labels \texttt{Free\_Var} for \cvar{'var} and \cvar{'tyvar}, \texttt{Bound\_Var} for \cvar{'bvar} and \cvar{'btyvar}, and \texttt{Live\_Var} for \cvar{'body} and \cvar{'rec} (as the variable of \text{ID\_mrbnf} is already a live variable, demoting it to \texttt{Live\_Var} does nothing).

\subsection{Conversion from BNF to MRBNF}\label{sec:conversion}

As seen in section~\ref{sec:mrbnf_theory}, \acp{MRBNF} are a generalization of \acp{BNF}. This means every \ac{BNF} is also a \ac{MRBNF} that only has live and dead variables, no free or bound variables. The function \textit{mrbnf\_of\_bnf} provides the tactics that prove the \ac{MRBNF} axioms from the \ac{BNF} axioms.

One notable change that has to be done is the bound. The \textit{set\_bd} \ac{BNF} axiom requires that the set returned by the set functions is smaller or equal to the cardinal bound (see equation~\ref{eq:bnf_set_bd} in section~\ref{sec:theory}). The \ac{MRBNF} axioms require a strictly smaller set than the cardinal bound, so we cannot simply use the same cardinal for the \ac{MRBNF} as for the \ac{BNF}. Because of this, \textit{mrbnf\_of\_bnf} uses the successor cardinal as bound.

\subsection{\ac{MRBNF} composition}\label{sec:composition}

To compose multiple \acp{MRBNF} together, we need to prove the \ac{MRBNF} axioms of the combined type given the axioms of the individual components. For example, the type \texttt{\cvar{'a} ID\_mrbnf + \cvar{'a} list}

\begin{itemize}
\item{Complex case --> easy case}
\end{itemize}

\subsection{Demotion of variables}\label{sec:demote}

\begin{itemize}
\item{Converts live --> free --> bound --> dead}
\item{Needed to match vars of multiple MRBNFs during composition}
\end{itemize}

\subsection{Lifing and Permutation of variables}\label{sec:lift}

\begin{itemize}
\item{Lift: Add new (unused) variables to the front of the type}
\item{Used to make multiple MRBNFs have the same number of variables of each type}
\item{Permute: Change order of variables of a MRBNF}
\item{Composition needs all variables in the same order for each MRBNF}
\end{itemize}

\subsection{MRBNF composition}\label{sec:clean_composition}

\begin{itemize}
\item{Explain how to combine axioms of multiple MRBNFs to one composed MRBNF}
\end{itemize}

\section{Fixpoint construction of the data type}

\begin{itemize}
\item{Partly implemented by Stoop~\cite{mrbnf_fixpoint}}
\item{Use the greatest or least fixpoint of the pre-datatype to obtain a recursive datatype}
\item{Generates a recursor/corecursor that can be used to write functions}
\item{Generates an weak induction principle}
\end{itemize}
