\chapter{Comparison with existing solutions}\label{chapter:comparison}

\begin{itemize}
\item{Nominal2}
\item{De Bruin indices}
\item{Locally Nameless}
\end{itemize}


TODO: Fix this

The Nominal2 package~\cite{nominal2} that is currently used to reason about data types with binders, allows to specify a function which extracts the binders from a type. This function is very limited and does not support data types that were not defined in the same mutually recursive group. This forces the user to create a new list type instead of using a normal list of tuples (see listing~\ref{lst:letrec_nominal}).

\begin{lstlisting}[
  language=Isabelle,
  caption=Defintion of a simple expression type with recursive lets in Nominal2,
  label={lst:letrec_nominal}
]
atom_decl var

nominal_datatype expr =
    Var var
  | Lam "x::var" "t::expr" binds x in t
  | App "t1::expr" "t2::expr"
  | Let "as::binder_list" "t::expr" binds bn(as) in t
  | LetRec "as::binder_list" "t::expr" binds bn(as) in as t
and binder_list =
    ANil
  | ACons var expr binder_list
binder bn :: "binder_list => atom list" where
    "bn ANil = []"
  | "bn (ACons x _ as) = atom x # bn as"
\end{lstlisting}

Our binding aware data types will not need this auxilliary list type nor the extraction function. As a future addition they can however support non-repetitive binders and more. At the time of writing most of the implementation is still missing, so it is hard to anticipate which syntactic features might be relevant in the future. For this reason this thesis does not choose a specific syntactic format and expects the user to provide the already translated types and the binding relation (see section~\ref{sec:binding relation}). The translation of the example above could look like listing~\ref{lst:binding_pre_datatype}. Note that contrary to Nominal2, variables in our binding aware data types are not specified with an extra command (like \texttt{atom\_decl}), but are a argument to the data type instead.

